searchState.loadedDescShard("linera_views", 0, "This module is used in the Linera protocol to map complex …\nBackend implementing the <code>crate::store::KeyValueStore</code> trait.\nThe definition of the batches for writing in the database. …\nCommon definitions used for views and backends. This …\nThe <code>Context</code> trait and related definitions.\nSupport for metrics.\nFunctions for random generation\nThe <code>KeyValueStore</code> trait and related definitions. This …\nHelper types for tests.\nElementary data-structures implementing the <code>views::View</code> …\nImplements <code>crate::store::KeyValueStore</code> by combining two …\nImplements <code>crate::store::KeyValueStore</code> for the DynamoDB …\nTurns a <code>DirectKeyValueStore</code> into a <code>KeyValueStore</code> by adding …\nAdd LRU (least recently used) caching to a given store.\nImplements <code>crate::store::KeyValueStore</code> in memory.\nAdds metrics to a key-value store.\nImplements <code>crate::store::KeyValueStore</code> for the RocksDB …\nImplements <code>crate::store::KeyValueStore</code> for the ScyllaDB …\nAdds support for large values to a given store by …\nSerialization error with BCS.\nA store made of two existing stores.\nThe initial configuration of the system.\nThe error type for <code>DualStore</code>.\nAn iterator over the keys in <code>DualStoreKeys</code>.\nAn iterator over the key-values in <code>DualStoreKeyValues</code>.\nAn owning iterator over the key-values in …\nA set of key-values returned by …\nA set of keys returned by <code>DualStore::find_keys_by_prefix</code>.\nThe trait for a (static) root key assignement.\nA set of keys from the first store.\nIterating over keys from the first store.\nA set of key-values from the first store.\nIterating over key-values from the first store.\nIterating over key-values from the first store.\nThe first store.\nFirst store.\nA set of Keys from the second store.\nIterating over keys from the second store.\nA set of key-values from the second store.\nIterating over key-values from the second store.\nIterating over key-values from the second store.\nThe second store.\nSecond store.\nThe store in use.\nObtains the store assigned to this root key.\nThe first config.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe second config.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nAn error occurred while writing a batch of items.\nA BCS error occurred.\nAn error occurred while building an object\nThe configuration to connect to DynamoDB.\nAn error occurred while creating the table.\nThe recovery failed.\nAn error occurred while deleting a table\nA set of <code>(key, value)</code> returned by a search query on …\nA set of keys returned by a search query on DynamoDB.\nA shared DB client for DynamoDb implementing LruCaching …\nThe config type for DynamoDbStore\nThe combined error type for the <code>DynamoDbStore</code>.\nA DynamoDB client.\nThe initial configuration of the system\nErrors that occur when using <code>DynamoDbStoreInternal</code>.\nAn error occurred while getting the item.\ninner store error\nallowed characters are lowercase letters, numbers, periods …\nError when validating a namespace\nA wrong namespace error occurred\nThe journal is not coherent\nThe key prefix must have at most 1024 bytes\nThe key must have at most 1024 bytes\nAn error occurred while listing tables\nThe stored key is missing.\nvalue segment is missing from the database\nThe value attribute is missing.\nno count of size u32 is available in the value\nAn error occurred while doing a Query.\nThe namespace should be at most 63 characters.\nThe namespace should be at least 3 characters.\nThe key is of length less than 4, so we cannot extract the …\nThe transact maximum size is MAX_TRANSACT_WRITE_ITEM_SIZE.\nAn error occurred while writing a transaction of items.\nThe length of the value should be at most 400KB.\nThe type of the keys was not correct (It should have been …\nThe value was stored as the wrong type (it should be a …\nKeys have to be of non-zero length.\nKey prefixes have to be of non-zero length.\nThe cache size being used\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGetting a configuration for the system\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>DynamoDbStoreConfig</code> from the input.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nCreates a <code>DynamoDbStoreInternalError::WrongKeyType</code> …\nCreates a <code>DynamoDbStoreInternalError::WrongValueType</code> …\nThe batch type.\nLow-level, asynchronous direct read/write key-value …\nLow-level, asynchronous direct write key-value operations …\nThe journal block could not be retrieved, it could be …\nData type indicating that the database is not consistent\nA journaling Key Value Store built from an inner …\nThe maximal number of items in a batch.\nThe maximal number of bytes of a batch.\nThe maximal size of values that can be stored.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe read stuff does not change\nCreates a new journaling store.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the batch to the database.\nThe configuration type for the <code>LruCachingStore</code>.\nA memory store with caching.\nWe take a store, a maximum size and build a LRU-based …\nThe standard cache size used for tests.\nGets the <code>cache_size</code>\nThe cache size being used\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>RocksDbStoreConfig</code> from the input.\nCreates a <code>ScyllaDbStoreConfig</code> from the inputs.\nCreates a <code>DynamoDbStoreConfig</code> from the input.\nCreates a new key-value store that provides LRU caching at …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nSerialization error with BCS.\nA virtual DB client where data are persisted in memory.\nThe initial configuration of the system\nThe error type for <code>MemoryStore</code>.\nThe namespace does not exist\nThe number of streams for the test\nThe value is too large for the MemoryStore\nThe common configuration of the key value store\nCreates a test memory store for working.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>MemoryStoreConfig</code>. <code>max_concurrent_queries</code> and …\nCreates a <code>MemoryStore</code> from a number of queries and a …\nCreates a <code>MemoryStore</code> from a number of queries and a …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe implementation of the <code>KeyValueStoreMetrics</code> for the …\nA metered wrapper that keeps track of every operation\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreation of a named Metered counter.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nBCS serialization error.\nThis uses the <code>block_in_place</code> function of tokio.\nFilesystem error\ninner store error\nError converting <code>OsString</code> to <code>String</code>\nNamespace contains forbidden characters\nThe key must have at most 8M\nvalue segment is missing from the database\nno count of size u32 is available in the value\nThe database contains a file which is not a directory\nA path and the guard for the temporary directory if needed\nRocksDB error.\nThe choice of the spawning mode. <code>SpawnBlocking</code> always …\nThe <code>RocksDbStore</code> composed type with metrics\nThe composed config type for the <code>RocksDbStore</code>\nThe composed error type for the <code>RocksDbStore</code>\nThe inner client\nThe initial configuration of the system\nThe error type for <code>RocksDbStoreInternal</code>\nThis uses the <code>spawn_blocking</code> function of tokio.\nTokio join error in RocksDb.\nThe key is of length less than 4, so we cannot extract the …\nThe cache size being used\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nObtains the spawning mode from runtime.\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>RocksDbStoreConfig</code> from the input.\nCreate a PathWithGuard from an existing path.\nReturns the test path for RocksDB without common config.\nThe path to the data\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe batch is too long to be written\nBCS serialization error.\ninner store error\nNamespace contains forbidden characters\nThe journal is not coherent\nThe key must have at most [‘MAX_KEY_SIZE’] bytes\nvalue segment is missing from the database\nno count of size u32 is available in the value\nA query error in ScyllaDB\nA query error in ScyllaDB\nA row error in ScyllaDB\nThe <code>ScyllaDbStore</code> composed type with metrics\nThe <code>ScyllaDbStoreConfig</code> input type\nThe combined error type for the <code>ScyllaDbStore</code>.\nThe client itself and the keeping of the count of active …\nThe type for building a new ScyllaDB Key Value Store\nThe error type for <code>ScyllaDbStoreInternal</code>\nThe key is of length less than 4, so we cannot extract the …\nThe value must have at most [‘MAX_VALUE_SIZE’] bytes\nThe cache size being used\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>ScyllaDbStoreConfig</code> from the inputs.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe url to which the requests have to be sent\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\ninner store error\nA memory store for which the values are limited to 100 …\nvalue segment is missing from the database\nno count of size u32 is available in the value\nThe key is of length less than 4, so we cannot extract the …\nThe composed error type built from the inner error type.\nA key-value store with no size limit for values.\nProvides a <code>LimitedTestMemoryStore&lt;()&gt;</code> that can be used for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new store that deals with big values from one …\nCreates a <code>LimitedTestMemoryStore</code>\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA batch of write operations.\nAn iterator-like object that can write values one by one …\nDelete the given key.\nDelete all the keys matching the given prefix.\nA trait to expand delete_prefix operations. Certain …\nThe error type that can happen when expanding the …\nThe error type that can happen when expanding the …\nThe iterator type used to process values from the batch.\nA trait to expand delete_prefix operations. Certain …\nSet or replace the value of a given key.\nA batch of deletions and insertions that operate on …\nThe iterator that corresponds to a SimpleUnorderedBatch\nA notion of batch useful for certain computations (notably …\nAn unordered batch of deletions and insertions, together …\nThe iterator that corresponds to a SimpleUnorderedBatch\nA write operation as requested by a view when it needs to …\nAdds the deletion of key to the batch.\nAdds the insertion of a key-value pair to the batch.\nBuilds a batch from a builder function.\nChecks the size of the values of the batch.\nInserts the deletion of a <code>key</code> into the batch.\nInserts the deletion of a <code>key_prefix</code> into the batch.\nThe deletions.\nModifies an <code>UnorderedBatch</code> so that the key-prefix …\nReturns the list of keys to be appended to the list.\nReturns the list of keys to be appended to the list.\nFrom an <code>UnorderedBatch</code>, creates a <code>SimpleUnorderedBatch</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a simplified batch from a standard one.\nThe insertions.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an owning iterator over the values in the batch.\nReturns true if there are no more values to write.\nWhether the batch is empty or not\nTests whether the batch is empty or not\nReturns true if the batch is empty.\nThe key-prefix deletions.\nReturns the total number of entries in the batch.\nThe total number of entries of the batch.\nCreates an empty batch.\nComputes the batch size that we would obtain if we wrote …\nReturns the total number of bytes in the batch.\nReturns the number of operations in this <code>Batch</code>.\nThe write operations.\nReturns the overhead size of the batch.\nAdds the insertion of a key-value pair into the batch with …\nAdds the insertion of a <code>(key, value)</code> pair into the batch …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe batch of deletions and insertions.\nSimplifies the batch by removing operations that are …\nThe total size of the batch\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the next value (if any) to the batch and updates …\nThe key that will be deleted.\nThe key to be inserted or replaced.\nThe prefix of the keys to be deleted.\nThe value to be inserted on the key.\nSometimes we need a serialization that is different from …\nDeserialize the vector\nSerializes the value\nThe context in which a view is operated. Typically, this …\nThe error type in use by internal operations.\nUser-provided data to be carried along.\nReturns type for key-value search operations.\nReturns type for key search operations.\nThe maximal size of keys that can be stored.\nThe maximal size of values that can be stored.\nAn implementation of <code>crate::context::Context</code> that stores …\nImplementation of the <code>Context</code> trait on top of a DB client …\nConcatenates the base_key and index.\nGetter for the address of the base key.\nConcatenates the base_key and tag.\nConcatenates the base_key, tag and index.\nObtains a similar <code>Context</code> implementation with a different …\nTests whether a key exists in the database\nTests whether a set of keys exist in the database\nCreates a context suitable for a root view, using the …\nProvides a <code>MemoryContext&lt;()&gt;</code> that can be used for tests.\nObtains the <code>Vec&lt;u8&gt;</code> key from the key by serialization and …\nObtains the short <code>Vec&lt;u8&gt;</code> key from the key by …\nObtains the <code>Vec&lt;u8&gt;</code> key from the key by serialization and …\nDeserialize <code>bytes</code> into type <code>Item</code>.\nGetter for the user-provided data.\nFinds the <code>(key,value)</code> pairs matching the <code>key_prefix</code>. The …\nFinds the keys matching the <code>key_prefix</code>. The <code>key_prefix</code> is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRetrieves the number of stream queries.\nCreates a <code>Context</code> instance in memory for testing.\nCreates a <code>Context</code> instance in memory for testing.\nCreates a context for the given base key, store, and an …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads multiple <code>keys</code> and deserializes the results if …\nRetrieves multiple <code>Vec&lt;u8&gt;</code> from the database using the …\nRetrieves a generic <code>Item</code> from the database using the …\nRetrieves a <code>Vec&lt;u8&gt;</code> from the database using the provided …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nApplies the operations from the <code>batch</code>, persisting the …\nIncrements the metrics counter with the given name, with …\nA deterministic RNG.\nA RNG that is non-deterministic if the platform supports …\nReturns the argument unchanged.\nGet a random alphanumeric string that can be used for all …\nReturns a unique namespace for testing.\nCalls <code>U::from(self)</code>.\nReturns a deterministic RNG for testing.\nReturns a non-deterministic RNG where supported.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nAccess the internal RNG.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nLow-level trait for the administration of stores and their …\nThe name of the backend.\nThe common initialization parameters for the <code>KeyValueStore</code>\nThe common initialization parameters for the <code>KeyValueStore</code>\nThe configuration needed to interact with a new store.\nThe configuration needed to interact with a new store.\nThe error type.\nThe iterator returning keys by reference.\nThe iterator that returns key-value pairs by reference.\nThe iterator that returns key-value pairs by value.\nHow to iterate over the keys returned by a search query.\nHow to iterate over the key-value pairs returned by a …\nLow-level, asynchronous write and read key-value …\nThe error type for the key-value stores.\nReturns type for key-value search operations.\nReturns type for key-value search operations.\nReturns type for key search operations.\nReturns type for key search operations.\nLow-level trait for the administration of stores and their …\nLow-level, asynchronous write and read key-value …\nLow-level, asynchronous read key-value operations. Useful …\nLow-level, asynchronous write and read key-value …\nLow-level, asynchronous write key-value operations. Useful …\nThe maximal size of keys that can be stored.\nThe maximal size of keys that can be stored.\nThe maximal size of values that can be stored.\nThe maximal size of values that can be stored.\nLow-level, asynchronous read key-value operations. Useful …\nLow-level, asynchronous write and read key-value …\nThe functions needed for testing purposes\nDefine an associated <code>KeyValueStoreError</code>.\nLow-level, asynchronous write key-value operations. Useful …\nThe cache size being used.\nClears any journal entry that may remain. The journal is …\nClears any journal entry that may remain. The journal is …\nTakes a connection and creates a new one with a different …\nTakes a connection and creates a new one with a different …\nConnects to an existing namespace using the given …\nConnects to an existing namespace using the given …\nTests whether a key exists in the database\nTests whether a key exists in the database\nTests whether a list of keys exist in the database\nTests whether a list of keys exist in the database\nCreates a namespace. Returns an error if the namespace …\nCreates a namespace. Returns an error if the namespace …\nDeletes the given namespace.\nDeletes the given namespace.\nDeletes all the existing namespaces.\nDeletes all the existing namespaces.\nTests if a given namespace exists.\nTests if a given namespace exists.\nFinds the <code>(key,value)</code> pairs matching the prefix. The …\nFinds the <code>(key,value)</code> pairs matching the prefix. The …\nFinds the <code>key</code> matching the prefix. The prefix is not …\nFinds the <code>key</code> matching the prefix. The prefix is not …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe name of this class of stores\nThe name of this class of stores\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterates keys and values by value.\nIterates keys by reference.\nIterates keys and values by reference.\nObtains the list of existing namespaces.\nObtains the list of existing namespaces.\nThe number of concurrent to a database\nThe number of concurrent to a database\nRetrieve the number of stream queries.\nRetrieve the number of stream queries.\nThe number of streams used for the async streams.\nThe number of streams used for the async streams.\nInitializes a storage if missing and provides it.\nInitializes a storage if missing and provides it.\nObtains a test config\nCreates a store for testing purposes\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads multiple <code>keys</code> and deserializes the results if …\nReads multiple <code>keys</code> and deserializes the results if …\nRetrieves multiple <code>Vec&lt;u8&gt;</code> from the database using the …\nRetrieves multiple <code>Vec&lt;u8&gt;</code> from the database using the …\nReads a single <code>key</code> and deserializes the result if present.\nReads a single <code>key</code> and deserializes the result if present.\nRetrieves a <code>Vec&lt;u8&gt;</code> from the database using the provided …\nRetrieves a <code>Vec&lt;u8&gt;</code> from the database using the provided …\nCreates a new storage. Overwrites it if this namespace …\nCreates a new storage. Overwrites it if this namespace …\nGets the reduced <code>CommonStoreInternalConfig</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>batch</code> in the database.\nWrites the <code>batch</code> in the database.\nAdds a prefix to a list of key-values\nExercises the functionalities of the <code>AdminKeyValueStore</code>. …\nReading many keys at a time could trigger an error. This …\nTakes a random number generator, a key_prefix and extends …\nReturns a random key_prefix used for tests\nA bunch of puts and some deletes.\nTakes a random number generator rng, a number n and …\nGenerates a list of random key-values with no duplicates\nTakes a random number generator, a key_prefix and generates\nBuilds a random k element subset of n\nWe build a number of scenarios for testing the reads.\nAppends a small value to a key making collisions likely.\nFunctions for computing the performance of stores.\nDynamoDb has limits at 1M (for pagination), 4M (for write) …\nThis test starts with a collection of key/values being …\nWrites and then reads data under a prefix, and verifies …\nRun many operations on batches always starting from a …\nRun some deterministic and random batches operation and …\nA random reordering of the puts and deletes. For something …\nSome <code>View</code>s that are easy to use with test cases.\nThat test is especially challenging for ScyllaDB. In its …\nBenchmarks the <code>contains_key</code> operation.\nBenchmarks the <code>contains_keys</code> operation.\nBenchmarks the <code>find_keys_by_prefix</code> operation.\nBenchmarks the <code>find_keys_by_prefix</code> operation.\nBenchmarks the <code>read_multi_values_bytes</code> operation.\nBenchmarks the <code>read_value_bytes</code> operation.\nBenchmarks the <code>write_batch</code> operation.\nRepresentation of the view’s state.\nWrapper to test with a <code>CollectionView</code>.\nWrapper to test with a <code>LogView</code>.\nWrapper to test with a <code>MapView</code>.\nWrapper to test with a <code>RegisterView</code>.\nA <code>View</code> to be used in test cases.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads the view’s current state.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nStages some changes to the view that won’t be persisted …\nStages some changes to the view that will be persisted …\nPerforms some initial changes to the view, staging them, …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nArithmetic error\nBCS serialization error.\nSome blobs were not found.\nWe failed to acquire an entry in a CollectionView or a …\nA <code>ClonableView</code> supports being shared (unsafely) by cloning …\nA <code>RootView</code> that also supports crypto hash\nA <code>View</code> that also supports crypto hash\nA view that supports hashing its values.\nThe requirement for the hasher type in <code>HashableView</code>.\nHow to compute hashes.\nThe database is corrupt: Entries don’t have the expected …\nInput output error.\nThe key must not be too long\nThe minimum value for the view tags. Values in …\nThe database is corrupt: Some entries are missing\nThe number of keys used for the initialization\nFIXME(#148): This belongs to a future …\nThe output type.\nThe values are incoherent.\nA <code>View</code> whose staged modifications can be saved in storage.\nErrors within the context can occur and are presented as …\nTokio errors can happen while joining.\nThe value is too large for the client\nAn error happened while trying to lock.\nA view gives exclusive access to read and write the data …\nMain error type for the crate.\nThe <code>BucketQueueView</code> implements a queue that can push on …\nClears the view. That can be seen as resetting to default. …\nCreates a clone of this view, sharing the underlying …\nThe <code>CollectionView</code> implements a map structure whose keys …\nObtains a mutable reference to the internal context.\nComputing the hash and attributing the type to it.\nComputing the hash and attributing the type to it.\nFinishes the hashing process and returns its output.\nPersists changes to storage. This leaves the view still …\nReturns the argument unchanged.\nReturns <code>true</code> if flushing this view would result in changes …\nComputes the hash of the values.\nComputes the hash of the values.\nWrapping a view to compute a hash.\nCalls <code>U::from(self)</code>.\nThe implementation of a key-value store view.\nLoads a view\nThe <code>LogView</code> implements a log list that can be pushed.\nThe <code>MapView</code> implements a map with ordered keys. The <code>MapView</code>…\nBuilds a trivial view that is already deleted\nCreates a <code>NotFound</code> error with the given message and key.\nLoads a view from the values\nCreates the keys needed for loading the view\nThe <code>QueueView</code> implements a queue that can push on the back …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe <code>ReentrantCollectionView</code> implements a map structure …\nThe <code>RegisterView</code> implements a register for a single value.\nDiscards all pending changes. After that <code>flush</code> should have …\nSaves the root view to the database context\nThe <code>SetView</code> implements a set with ordered entries.\nSerializes a value with BCS and includes it in the hash.\nIncludes bytes in the hash.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nbackend can be e.g. RocksDB / DynamoDB / Memory / etc.\nerror is the specific problem that occurred within that …\nA view that supports a FIFO queue for values of type <code>T</code>. …\nType wrapping <code>QueueView</code> while memoizing the hash.\nReturns the last element of a bucket queue view\nThe total number of entries of the container\nDeletes the front value, if any.\nReturns the list of elements in the queue.\nReturns the argument unchanged.\nGets a reference on the front value if any.\nReads the front value, if any.\nCalls <code>U::from(self)</code>.\nGets a mutable iterator on the entries of the queue\nPushes a value to the end of the queue.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReturns the last element of a bucket queue view\nReturns the first elements of a bucket queue view\nGets the number of entries in the container that are stored\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA MapView that serializes the indices.\nType wrapping <code>ByteCollectionView</code> while memoizing the hash.\nType wrapping <code>CollectionView</code> while memoizing the hash.\nType wrapping <code>CustomCollectionView</code> while memoizing the …\nA read-only accessor for a particular subview in a …\nTests if the collection contains a specified key and …\nReturns the number of entries in the collection.\nReturns the number of entries in the collection.\nReturns the number of entries in the collection.\nGets the extra data.\nGets the extra data.\nGets the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index (aka key). Keys are …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the collection in the order …\nReturns the list of indices in the collection in the order …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys in the collection. The order is …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nMarks the entry as removed. If absent then nothing is done.\nRemoves an entry from the CollectionView. If absent …\nRemoves an entry from the CollectionView. If absent …\nResets an entry to the default value.\nResets an entry to the default value.\nMarks the entry so that it is removed in the next flush.\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA hash for ContainerView and storing of the hash for …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nBCS serialization error.\nA view that represents the functions of KeyValueStore …\nA pair containing the key and value size.\nA virtual DB client using a <code>KeyValueStoreView</code> as a backend …\nThe error type for <code>ViewContainer</code> operations.\nView error.\nAdd a size to the existing SizeData\nTests whether the store contains a specific index.\nTests whether the view contains a range of indices\nReturns the number of entries.\nIterates over all the key-value pairs, for keys matching …\nIterates over all the keys matching the given prefix. The …\nApplies the function f over all indices.\nApplies the function f over all index/value pairs.\nApplies the function f over all index/value pairs. If the …\nApplies the function f over all indices. If the function f …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nObtains the value at the given index, if any.\nReturns the list of indices and values in lexicographic …\nReturns the list of indices in lexicographic order.\nSets or inserts a value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe size of the key\nObtains the values of a range of indices\nCreates a <code>ViewContainer</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value. If absent then the action has no effect.\nDeletes a key_prefix.\nSubtract a size to the existing SizeData\nSums both terms\nSums both terms\nGetting the total sizes that will be used for keys and …\nThe size of the value\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nApplies the given batch of <code>crate::common::WriteOperation</code>.\nType wrapping <code>LogView</code> while memoizing the hash.\nA view that supports logging values of type <code>T</code>.\nReads the size of the log.\nObtains the extra data.\nReturns the argument unchanged.\nReads the logged value with the given index (including …\nCalls <code>U::from(self)</code>.\nReads several logged keys (including staged ones)\nPushes a value to the end of the log.\nReads the logged values in the given range (including …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA view that supports inserting and removing values indexed …\nThe serialization.\nA Custom MapView that uses the custom serialization\nType wrapping <code>ByteMapView</code> while memoizing the hash.\nType wrapping <code>CustomMapView</code> while memoizing the hash.\nType wrapping <code>MapView</code> while memoizing the hash.\nA <code>View</code> that has a type for keys. The ordering of the …\nThe value itself.\nWhether we have a value or its serialization.\nReturns <code>true</code> if the map contains a value for the specified …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns the number of keys of the map\nObtains the number of entries in the map\nObtains the number of entries in the map\nObtains the extra data.\nObtains the extra data.\nObtains the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function on each index/value pair. Indices and …\nApplies a function f on each index/value pair. Indices and …\nApplies a function f on each index/value pair. Indices and …\nApplies a function f on the index/value pairs. Indices and …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies the function f on each index (aka key) having the …\nApplies a function f on each key/value pair matching a …\nApplies a function f on each index/value pair matching a …\nApplies the function f on each index (aka key) which has …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReads the value at the given position, if any.\nReads the value at the given position, if any.\nReads the value at the given position, if any.\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position.\nObtains a mutable reference to a value at a given position.\nObtains a mutable reference to a value at a given position.\nObtains all the <code>(index,value)</code> pairs.\nObtains all the <code>(index,value)</code> pairs.\nReturns the list of indices in the map. The order is …\nReturns the list of indices in the map. The order is …\nInserts or resets the value of a key of the map.\nInserts or resets a value at an index.\nInsert or resets a value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys and values of the map in …\nReturns the list of keys and values of the map matching a …\nReturns the list of keys of the map in lexicographic order.\nReturns the list of keys of the map having a specified …\nReads the values at the given positions, if any.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value. If absent then nothing is done.\nRemoves a value. If absent then the operation does nothing.\nRemoves a value. If absent then this does not do anything.\nRemoves a value. If absent then nothing is done.\nConvert to bytes.\nConvert to a value.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>QueueView</code> while memoizing the hash.\nA view that supports a FIFO queue for values of type <code>T</code>.\nReads the back value, if any.\nReads the size of the queue.\nDeletes the front value, if any.\nReads all the elements\nObtains the extra data.\nReturns the argument unchanged.\nReads the front value, if any.\nCalls <code>U::from(self)</code>.\nGets a mutable iterator on the entries of the queue\nPushes a value to the end of the queue.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads the <code>count</code> last values in the queue (including staged …\nReads the <code>count</code> next values in the queue (including staged …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>ReentrantByteCollectionView</code> while memoizing …\nType wrapping <code>ReentrantCollectionView</code> while memoizing the …\nType wrapping <code>ReentrantCustomCollectionView</code> while …\nA read-only accessor for a particular subview in a …\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA read-write accessor for a particular subview in a …\nReturns <code>true</code> if the collection contains a value for the …\nReturns <code>true</code> if the collection contains a value for the …\nReturns <code>true</code> if the collection contains a value for the …\nReturns the number of indices of the collection.\nReturns the number of indices in the collection.\nReturns the number of entries in the collection.\nGets the extra data.\nGets the extra data.\nGets the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index (aka key). Keys are …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the collection in an order …\nReturns the list of indices in the collection. The order …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of indices in the collection in …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves an entry. If absent then nothing happens.\nMarks the entry so that it is removed in the next flush.\nRemoves an entry. If absent then nothing happens.\nLoads all the entries for reading at once.\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoads all the entries for writing at once.\nLoads all entries for writing at once. The entries in …\nLoads all entries for writing at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoads multiple entries for writing at once. The entries in …\nLoad multiple entries for writing at once. The entries in …\nLoad multiple entries for writing at once. The entries in …\nLoads a subview at the given index in the collection and …\nLoads a subview at the given index in the collection and …\nLoads a subview at the given index in the collection and …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nMarks the entry so that it is removed in the next flush.\nMarks the entry so that it is removed in the next flush.\nMarks the entry so that it is removed in the next flush.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>RegisterView</code> while memoizing the hash.\nA view that supports modifying a single value of type <code>T</code>.\nObtains the extra data.\nReturns the argument unchanged.\nAccess the current value in the register.\nObtains a mutable reference to the value in the register.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nSets the value in the register.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA <code>View</code> that supports inserting and removing values indexed …\nA <code>View</code> implementing the set functionality with the index <code>I</code> …\nType wrapping <code>ByteSetView</code> while memoizing the hash.\nType wrapping <code>CustomSetView</code> while memoizing the hash.\nType wrapping <code>SetView</code> while memoizing the hash.\nA <code>View</code> implementing the set functionality with the index <code>I</code> …\nReturns true if the given index exists in the set.\nReturns true if the given index exists in the set.\nReturns true if the given index exists in the set.\nReturns the number of entries in the set.\nReturns the number of entries in the set.\nReturns the number of entries of the set.\nGets the extra data.\nObtains the extra data.\nObtains the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each serialized index (aka key). …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the set. The order is …\nReturns the list of indices in the set. The order is …\nInsert a value. If already present then it has no effect.\nInserts a value. If already present then no effect.\nInserts a value. If present then it has no effect.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys in the set. The order is …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value from the set. If absent then no effect.\nRemoves a value. If absent then nothing is done.\nRemoves a value. If absent then nothing is done.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.")